{"pages":[{"title":"","text":"Shoichi Ishida4-Year Ph.D. ProgramSynthetic Medicinal Chemistry, Graduate School of Pharmaceutical Science, Kyoto UniversityResearch Interests Computer-aided synthesys planning Application of machine learning for life sciences Papers S. Ishida, K. Terayama, R. Kojima, K. Takasu, Y. Okuno, “Prediction and Interpretable Visualization of Retrosynthetic Reactions Using Graph Convolutional Networks”, Journal of Chemical Information and Modeling, 2019. [DOI: 10.1021/acs.jcim.9b00538] International Conference and Workshop R. Kojima, H. Iwata, S. Ishida, M. Ikeguchi, Y. Okuno, “A Prediction Framework for Drug Discovery Using Graph Convolutional Networks”, 5th International Symposium for Medicinal Sciences (ISMS) (poster), Mar., 2019. Domestic Conference and Workshop 石田祥一, 寺山慧, 小島諒介, 高須清誠, 奥野恭史, “Interpretable Reaction Prediction using Graph Convolutional Networks”, CBI学会2019年大会, 2019/10/22~24, (oral) 石田祥一, 寺山慧, 小島諒介, 高須清誠, 奥野恭史, “GCN 記述子とモンテカルロ木探索を用いた合成経路予測”, CBI学会2019年大会, 2019/10/22~24, (oral: sponsored session) 池口茉莉恵, 石田祥一, 小島諒介, 岩田浩明, 奥野恭史, “Prediction of Compound-Protein Interactions and Visualization Based on Graph Convolutional Networks”, CBI学会2019年大会, 2019/10/22~24, (poster) 渋川亮祐, 石田祥一, 寺山慧, 美添一樹, 奥野恭史, 津田宏治, “証明数探索を用いた化合物合成経路列挙アルゴリズム”, 第21回情報論的学習理論ワークショップ, 2018/11. (oral: 学生優秀プレゼンテーション賞 ファイナリスト) Review article 寺山慧, 石田祥一, 奥野恭史, “AIによる逆合成解析に向けて”, 月刊「細胞」, Vol.51, No.7, pp.12-15, 2019/5. 寺山慧, 石田祥一, 奥野恭史, “囲碁AIから逆合成解析へ−情報科学からのアプローチ”, 化学, Vol.74 No.2, pp.36-40, 2019/1.","link":"/about/index.html"}],"posts":[{"title":"本の自炊（PDF化）〜管理方法(iPhone, iPadユーザー向け)","text":"私はいつも年末年始に一年間で購入した書籍をPDF化（自炊）して処分・整理しています（Kindleで売られていない書籍はまだまだ多いです）。 そこでこの記事では私が書籍の自炊をする際に使用している道具・アプリの紹介と手順をまとめていきます。 使用道具・アプリケーション ScanSnap iX500 DURODEX 自炊裁断機 ブラック 200DX iCloud(ストレージプラン50GB) Booklover 自炊手順 裁断機で書籍の背の部分を切り落とす 分厚い書籍は一度カッターで分割してから カバーも別で表・裏表紙をカッターで切り分ける（PDFの先頭がサムネイルに使う） ScanSnapで読み込みPDF化 スキャン前にきちんと裁断されているか確認する 1枚目は表表紙をスキャンするようにする ページ数にもよるが大体1冊5~10分くらい(25枚/分) iCloudのBookloverのフォルダに追加する ファイル名でメタデータの管理をする ファイル名からのメタデータ抽出→ジャンル→「抽出条件」を「1番目の()内」に変更しておく [著者名]_(ジャンル名)_書籍名.pdfで保存 各デバイスでメタデータの抽出 ファイル名からのメタデータ抽出→「すべての本のファイル名からメタデータを抽出」を実行 おわりに 以上が一連の流れになります。本の自炊はかなり体力を使うので、裁断等は外注してしまうのもありだと思います。 私は今までの教科書等も全て自炊してしまい処分しています。自炊してよかったなと思うところは、 教科書・専門書等普段は重くて持ち歩けないものもスマホ・タブレットでサッと確認できる OCRも使えば検索ができるようになる 引越しのたびに本を移動させる手間がなくなったあたりです。 もし興味があるけど購入するのはちょっとなあという人は、DMMで自炊キットのレンタルなどもありますので、 そちらを利用してみるのもアリだと思います（私は利用したことないので評価はできないですが。。） 以上で、私の書籍の自炊方法・管理の紹介を終わります。","link":"/2020/01/02/book-to-pdf/"},{"title":"はじめに","text":"ケムインフォを中心に創薬関連の研究している学生です。このブログには備忘録的に以下に関連するトピックを不定期にまとめていくつもりです。 Chemoinformatics Machine Learning Programming Medicine etc. 私についてはこちらを参照ください。","link":"/2019/12/09/intro/"},{"title":"Python環境構築(pyenv + pyenv-virtualenv)","text":"普段私はpyenv + pyenv-virtualenvの組み合わせでpythonの環境管理をしています。今回の記事ではその設定方法について記載していきます。 記事中で登場するファイルをダウンロードすればそのまま使用できます。 動作確認はLinux, MaxOSでしてます。 Install pyenv and pyenv-virtualenv 下記のスクリプトをダウンロードして、 ターミナルを起動してダウンロードした場所に移動した後に、下記のコマンドを実行して下さい。 1bash install_pyenv.sh インストールが終わったら一度ターミナルを立ち上げ直して下さい。 これでpyenv + pyenv-virtualenvのインストールは完了です。 Set virtual environment Install minicondapython環境は全てpyenv-virtualenv上で管理しています。そうすることで環境の使い捨てが簡単になるので便利です。 12pyenv install miniconda3-4.2.12pyenv shell miniconda3-4.2.12 Create home environmentインストールしたminiconda上でcondaコマンドを使用すると、condaのバージョンが上がってpyenvがおかしくなります。 それを防ぐために仮想home環境を作成し、そこをデフォルトの作業環境とします。 12conda create -n home python=3.6pyenv global miniconda3-4.2.12/envs/home Create test environmentあとはテーマ毎等で仮想環境を作って個別に管理します。 そうすることで各環境を最小構成にすることができて干渉する心配もありません。ここでは試しにcalc環境を作成します。 123conda create -n calc python=3.6pyenv shell miniconda3-4.2.12/envs/calcconda install -c rdkit rdkit 簡単ではありますが、以上でpythonの環境構築についての解説を終わります。 何かご質問等ありましたらコメントにお願いします。","link":"/2019/12/09/pyenv/"},{"title":"rdMolDraw2Dを用いて単色の分子を描画する","text":"本記事では、RDKitを使って原子が色分けされていない単色の分子を描画する方法について記載します。 いろいろな記事で分子の描画方法については記載があったのですが、原子の色を調整する方法は載っていなかった&やり方にたどり着くまで試行錯誤が必要だったのでまとめることにしました。 処理としては1行で済むので簡単です。 rdMolDraw2Dを使った基本的な分子の描画方法については、こちらのブログに丁寧にまとめられていますのでそちらを参照ください。 環境・ライブラリ python: 3.6 rdkit: 2019.09.2 ipython: 7.1.1 スクリプト 以下のスクリプトを実行すると黒色単色で分子を描画することができます。 このスクリプトの出力ファイルの中身は以下の通りです。 解説 分子の色を調整しているのは12行目の drawer.drawOptions().updateAtomPalette({k: (0, 0, 0) for k in DrawingOptions.elemDict.keys()}) になります。 DrawingOptions.elemDict.keys() で分子中の各原子のkeyを取得 取得したkeyに (0, 0, 0) を割り当てる。（これはRGB表記の黒を意味しています） 作成したdictを drawer.drawOptions().updateAtomPalette() を使ってatom paletteの更新 以上の処理で分子の色を調整しています。RGB表記の値を変えれば望みの色に分子を統一することが可能です。 12行目をコメントアウトすると、以下の通りヘテロ原子に色がついた分子の描画ができます。 他にも色々とdrawerのオプションは調整できますが、それはRDkitのAPIドキュメントを参照してください。 以上で終わります。 参照 RDKitでの構造式描画を詳しく解説rdkit.Chem.Draw.rdMolDraw2D module","link":"/2020/01/07/rdkit-draw-mol/"},{"title":"LaTeXからWordに変換する方法(Mac)","text":"Overleafで論文のやり取りをする際、有料版でないとコメント機能が使えないです。そのためlatexからwordファイルに変換したいと思い調べました。 いくつかの方法（latex2rtf, pandoc, GrindEQ）がよくヒットしますが、一番シンプルかつ他にも汎用性のあると感じた方法を以下に記載します。 ※参照のサイトではMacではできずWindowsのみで今回の方法が機能したと記載されてますが、Macでもできたのでまとめました。 環境 macOS Catalina: 10.15.1 Microsoft Word for Mac: 16.32 Overleaf 方法 1. Overleafに対象のlatexをアップロードし、PDFでダウンロードする。 2. そのPDFをWordで開く。 以上で終わりです。（WordでPDFが開けるということを知っている人からすれば当たり前な方法ですかね。。） 終わりに さすがにFigureとかは崩れてしまうので完璧とまでは言えないですが、コメントのやり取り程度の用途でしたら十分です。 参照 In a Word: LaTeX to Word and vice versa Exporting your work from Overleaf pandoc GrindEQ latex2rtf","link":"/2019/12/15/latex-to-word/"},{"title":"リモートサーバ ー上のjupyter notebookをローカルPCで操作する","text":"ローカルPCではスペック不足のため、計算資源豊富なリモートサーバーでjupyter notebookを使いたいと思う人は結構いると思います。 この記事ではそのためのjupyter notebookの設定方法について記載します。 前提とする環境 リモートサーバーにsshでログインしている。 リモートサーバ ー上にpython環境が構築してあり、jupyterがインストールされている。 リモートサーバ ーでのjupyter設定 jupyter notebookのconfigファイルを生成する 1jupyter notebook --generate-config これで以下の場所にconfigファイルができる。$HOME/.jupyter/jupyter_notebook_config.py 生成したconfigファイルの書き換えc.NotebookApp.~の項目が記載されている行を探し、アンコメントして以下の通り書き換える。 c.NotebookApp.ip = ‘localhost’c.NotebookApp.open_browser = Falsec.NotebookApp.port = 8889c.NotebookApp.token = u’’ 以上でサーバー側での設定は終わり。 ローカルPCからの操作 いつも通りsshする際に、ローカルフォワーディングする引数をつける。 例ではlocalhostのポート8889番をリモートサーバーの8889番につないでいる。 sshの引数は適宜追加して下さい。 1ssh -L 8889:localhost:8889 example.com このセッションを維持している状態で、jupyterを起動する。 普段使っているブラウザでhttp://localhost:8889/にアクセスするとリモートサーバで立ち上げたjupyter notebookに接続できる。 終わりに 他にも色々と設定することは可能だが、今回紹介した方法が最低限の設定だと思います。 もしセキュリティが不安だとか、もう少し細かく設定したいという場合は参照のリンク先をご覧ください。 参照 リモートサーバの Jupyter Notebook を SSH Port Forwarding 経由で使う Config file and command line options (Jupyter notebook document)","link":"/2019/12/12/remote-jupyter-notebook/"},{"title":"HomebrewでMacのパッケージ・アプリケーションの管理","text":"Macのアプリケーション管理は Homebrew を用いると便利です。 macOSにないパッケージは大体これでインストール可能なのと、 Homebrew-cask を使えばGUIアプリケーション（Google Chrome、Office系アプリ、etc.）もインストール・管理が可能です。 また、インストールしたものは Homebrew-file を使えばgit管理ができて新しいMacへの移行も楽になります。 MacユーザーならHomebrewを使わない理由はないくらいには便利なので、ぜひ以下の内容を参考に導入してみてください。 Homebrew macOSにないパッケージをインストールしてくれるmacOS用パッケージマネージャーです。 HomebrewThe Missing Package Manager for macOS (or Linux). Installインストールは下記をターミナルで実行するだけで完了です。 1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" このままだとbrewコマンドのtab補完が効かないので、以下の通り ~/.bash_profile に追記して bash-completion をインストールします。 ~/.bash_profile12345678910if type brew &>/dev/null; then HOMEBREW_PREFIX=\"$(brew --prefix)\" if [[ -r \"${HOMEBREW_PREFIX}/etc/profile.d/bash_completion.sh\" ]]; then source \"${HOMEBREW_PREFIX}/etc/profile.d/bash_completion.sh\" else for COMPLETION in \"${HOMEBREW_PREFIX}/etc/bash_completion.d/\"*; do [[ -r \"$COMPLETION\" ]] && source \"$COMPLETION\" done fifi 1brew install bash-completion あとは ~/.bash_profile を再読み込みするか新しいターミナルを立ち上げればtab補完が使えるようになります。 基本コマンドコマンド一覧は公式ドキュメントを参照してください。 色々と用意されていますが基本は、 brew install fomula brew search fomula brew uninstall fomula brew doctor # brew関連のtrouble shootingをしてくれる あたりが使えれば問題ないと思います。 BrewfileHomebrew用のGemfileです。 ここにbrewを通してインストールしたパッケージの依存関係が記載されます。 Brewfileは後述のHomebrew-fileを使って管理します。 Homebrew-cask macOSのGUIアプリケーション（Google Chrome、Office系アプリ、etc.）もHomebrewで管理できるようにしてくれる拡張パッケージです。 大体のGUIアプリケーションはこれでインストールできるので、これを使うとGUIアプリケーションの管理も楽になります。 最新のHomebrewだと標準で搭載されていると思います。 なのでインストールはTab補完の設定だけ記載します。 Install1brew install brew-cask-completion ~/.bash_profile への設定はHomebrewのtab補完の設定時にやっているもので大丈夫です。 基本コマンド brew cask install application brew cask uninstall application brew cask list # Homebrew-caskを通してインストールしたアプリ一覧の表示 Homebrew-file Brewfileを管理してくれるパッケージです。 私はこれを使ってBrewfileをgit管理することでバックアップをとっています。 Install1brew install rcmdnk/file/brew-file ~/.bashrc に以下を追加する（※ この設定は私のMacではうまく機能しないので、使用していません。） ~/.bashrc123if [ -f $(brew --prefix)/etc/brew-wrap ];then source $(brew --prefix)/etc/brew-wrapfi Brewfileの作成・管理公式ドキュメントにはDropboxとGitでの管理方法が記載されていますが、私はGitで管理していますのでその方法について記載します。※公式ドキュメントではbrew-wrapが設定できている前提で記載されています。今回は設定していないのでbrew-fileを使っています。 まずは自分のGitのレポジトリを設定します。 1brew-file set_repo 以下のコマンドを実行すると ~/.config/brewfile/Brewfile にBrewfileが作成されます。 1brew-file init そして以下のコマンドを実行すると設定したGitにBrewfileがpushされます。 1brew-file update 終わりに Homebrewでのパッケージ・アプリケーションの管理についてまとめました。 本当は私の使っているおすすめアプリまで紹介しようと思いましたが、記事のまとまりがなくなるのでそれは別の記事で紹介します。 参照 Homebrew Brewfile Homebrew Shell Completion Homebrew-cask homebrew-file","link":"/2020/01/14/homebrew/"},{"title":"当番をランダムに決めて通知してくれるSlack BotをGoogle Apps Scriptで作った","text":"研究室での毎週の当番決めを自動化したいと思い、Google Apps Script(GAS)を使ったSlack botを作成しました。 すでに作ってる人いるだろうなと検索したましたが、スプレッドシートから指定の人数をランダムにピックアップして当番を回していくGASが見つけられなかったです（スプレッドシートの全員に毎回割り当てるGASを書いている人は結構いたのですが）。 なのでこの記事では、作成したSlack Bot用のGASの公開と解説をしようと思います（Slack Botへの連携はこちらのサイトをご覧ください）。 Slack Botの使い方最初にSlack Botの使い方を載せておきます。とにかく使えれば良いという人は スプレッドシートの作成 作成したシートのスクリプトエディタに下記のスクリプトをコピペ Settingに必要な情報の記入 をすれば使えます。それ以降で、GASを書いていて思ったこととかをつらつらと書いていきます。 用意するスプレッドシートのフォーマット 1列目：SlackのメンバーID（で括る） 2列目：SlackのUser名 3列目：選択されたかどうかのマスク値（最初は1に設定する）（0: 割り当て済み, 1: 割当されていない） Google Apps ScriptdoPost() がメインの処理になります。3~7行目に必要情報を追記してください。 Settingに記載する情報 spreadSheetID: ‘https://docs.google.com/spreadsheets/d/＜IDはここの部分＞/edit#gid=0' sheetName: 読み込みたいスプレッドシートのシート名 pickNum: 毎週の担当に必要な人数 slackWebhookUrl: Incoming Webhookの設定時にできるURL Slack Botの設定参照サイトのやり方を見てください。 通知されるメッセージ通知されるメッセージは以下の通りです。メッセージを編集する場合は、65行目の template を編集してください。 感想JavaScriptはほとんど書いたことがなかったので、PythonやJavaと対応する処理ができないかなと思いながら調べつつ書いていきました （なので非効率的な処理とかも多くあると思うので、あればぜひご指摘お願いします）。 また、GASがJavaScript 1.6ベースで作られているため、それ以降で実装されている機能が使えないのも割と不便だと感じました（例えばアロー関数）。 このSlack Botの作成を通して、普段自分がいかにPythonが色々な機能・ライブラリを使っているのかを痛感しました。 Pythonではパッとできるのになあという処理ができないことが多くて、それの実装を追加したのもいい勉強になったなと思います。 以上でこの記事を終わります。 参照 Slack botを使って今週の掃除当番はどこだ問題を解決してみた！ Built-in Google Services","link":"/2020/01/27/role-assign-slack-bot/"},{"title":"Ubuntu server 18.04からWebDAV経由でownCloudにアクセスする","text":"ownCloudに大量のファイルをアップロードする際、リモートサーバ からローカルに落としてからやるのは非常に効率が悪いです。そこでこの記事ではUbuntuサーバ18.04にownCloudをマウント〜ファイルのアップロードまでの手順を紹介します。 環境・必要パッケージ Ubuntu 18.04 (sudoが使えること) Davfs2 ownCloud 10.0.8 手順 davfs2のインストールとマウントポイントの作成 123sudo apt install davfs2sudo usermod -aG davfs2 &lt;username&gt; # add yourself to the davfs2 groupmkdir ~/owncloud davfs2の設定 1234mkdir ~/.davfs2sudo cp /etc/davfs2/secrets ~/.davfs2/secrets # create personal davfs2 configuration filesudo chown &lt;username&gt;:&lt;username&gt; ~/.davfs2/secretschmod 600 ~/.davfs2/secrets ownCloudのアカウント情報を ~/.davfs2/secrets（davfs2の設定ファイル）に記入 1example.org/owncloud/remote.php/webdav &lt;username&gt; &lt;password&gt; example.orgは自分が使っているownCloudサーバのURLに置換する。 /etc/fstab にownCloudのマウントの記入をする 1example.org/owncloud/remote.php/webdav /home/&lt;username&gt;/owncloud davfs user,rw,noauto 0 0 /etc/fstab の各フィールドは以下になります。スペースかタブ区切りなので、そこら辺を注意してください。また、今回は自動マウントはして欲しくないのでnoautoで設定しています。 1&lt;device&gt; &lt;mountpoint&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;fsck&gt; ownCloudのマウント 1mount ~/owncloud これでownCloudがUbuntu server にマウントできます。これ以降はmount と umountをするだけで良いです。またファイルのアップロードをする際はrsyncを使うと差分のアップロードとかができるので良いです。 終わりにローカルPCで基本作業をしない人はこの設定をすると楽なのでおすすめです。 ハプニング最初にownCloudのマウントポイントを、別でマウントしているディレクトリに設定した際にbootが失敗する事態になりました。僕のようにならないよう、事前にfstabの仕組みをしっかり理解した上で作業するようにしてください。。 参照Davfs2 Accessing ownCloud Files Using WebDAV fstab","link":"/2020/02/15/access-owncloud-using-webdav-on-ubuntu18-04/"}],"tags":[{"name":"book_scanning","slug":"book-scanning","link":"/tags/book-scanning/"},{"name":"setup","slug":"setup","link":"/tags/setup/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"rdkit","slug":"rdkit","link":"/tags/rdkit/"},{"name":"cheminformatics","slug":"cheminformatics","link":"/tags/cheminformatics/"},{"name":"LaTeX","slug":"LaTeX","link":"/tags/LaTeX/"},{"name":"Word","slug":"Word","link":"/tags/Word/"},{"name":"Overleaf","slug":"Overleaf","link":"/tags/Overleaf/"},{"name":"jupyter_notebook","slug":"jupyter-notebook","link":"/tags/jupyter-notebook/"},{"name":"homebrew","slug":"homebrew","link":"/tags/homebrew/"},{"name":"macOS","slug":"macOS","link":"/tags/macOS/"},{"name":"Google_Apps_Script","slug":"Google-Apps-Script","link":"/tags/Google-Apps-Script/"},{"name":"Slack","slug":"Slack","link":"/tags/Slack/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"ownCloud","slug":"ownCloud","link":"/tags/ownCloud/"}],"categories":[{"name":"lifehack","slug":"lifehack","link":"/categories/lifehack/"},{"name":"programming","slug":"programming","link":"/categories/programming/"},{"name":"cheminformatics","slug":"cheminformatics","link":"/categories/cheminformatics/"},{"name":"macOS","slug":"macOS","link":"/categories/macOS/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"}]}